
package compi2.multi.compilator.analysis;

import java_cup.runtime.*;
import java.util.*;
import compi2.multi.compilator.analysis.symbolt.AccessMod;
import compi2.multi.compilator.analysis.typet.*;
import compi2.multi.compilator.analyzator.*;
import compi2.multi.compilator.semantic.*;
import compi2.multi.compilator.semantic.c.*;
import compi2.multi.compilator.semantic.cast.*;
import compi2.multi.compilator.semantic.cast.assign.*;
import compi2.multi.compilator.semantic.cast.dec.*;
import compi2.multi.compilator.semantic.cast.defaultfuncs.*;
import compi2.multi.compilator.semantic.cast.inv.*;
import compi2.multi.compilator.semantic.cexp.*;
import compi2.multi.compilator.semantic.util.*;
import compi2.multi.compilator.semantic.pexp.*;
import compi2.multi.compilator.semantic.pobj.*;
import compi2.multi.compilator.semantic.past.*;
import compi2.multi.compilator.semantic.pmodule.*;
import compi2.multi.compilator.semantic.jexp.*;
import compi2.multi.compilator.semantic.jclases.*;
import compi2.multi.compilator.semantic.jclases.components.*;
import compi2.multi.compilator.semantic.jast.*;
import compi2.multi.compilator.semantic.jast.inv.*;
import compi2.multi.compilator.semantic.jast.others.*;
import compi2.multi.compilator.util.Position;
import compi2.multi.compilator.util.Index;
/*-----------------------------------------------------------
  CUP Specification for the Parser Class
  -----------------------------------------------------------*/
parser code {:
    //fields
    Lexer lex;
    private List<String> syntaxErrors;
    private GenTypeTab genTypeTab;
    private AstGen astGen;
    private Analyzator analyzator;

    //conect the parser with the lexer
    public Parser(Lexer lex, Analyzator analyzator){
        super(lex);
        syntaxErrors = new LinkedList<>();
        genTypeTab = new GenTypeTab();
        astGen = new AstGen();
        this.analyzator = analyzator;
    }

    //getters
    public Lexer getLexer(){
        return this.lex;
    }
    public List<String> getSyntaxErrors(){
        return this.syntaxErrors;
    }
    
    /*SOBREESCRIBIR LOS METODOS DE ERROR*/
    public void syntax_error(Symbol cur_token) {
        StringBuilder mssBuilder = new StringBuilder("Simbolo: ");
        mssBuilder.append(symbl_name_from_id(cur_token.sym));
        
        if(cur_token.value != null){
            mssBuilder.append(", lexema <");
            mssBuilder.append(cur_token.value.toString());
            mssBuilder.append(">");
        }
        mssBuilder.append(", linea: ");
        mssBuilder.append(cur_token.left);
        mssBuilder.append(", columna: ");
        mssBuilder.append(cur_token.right);
        
        if (expected_token_ids().isEmpty()) {
            mssBuilder.append(" -- ya no se esperaba ningun simbolo");
        } else {
            mssBuilder.append(" -- Se esperaba [");
            for (Integer expected_token_id : expected_token_ids()) {
                if(!symbl_name_from_id(expected_token_id).equals("error")){
                    mssBuilder.append(symbl_name_from_id(expected_token_id));
                    mssBuilder.append(" ");
                }
                
            }
            mssBuilder.append("]");
        }
        syntaxErrors.add(mssBuilder.toString());
    }
    
    public void report_error(String message, Object info){
        try{
            Symbol cur_token = (Symbol) info;
            StringBuilder mssBuilder = new StringBuilder("Simbolo: ");
            mssBuilder.append(symbl_name_from_id(cur_token.sym));
            mssBuilder.append(", linea: ");
            mssBuilder.append(cur_token.left);
            mssBuilder.append(", columna: ");
            mssBuilder.append(cur_token.right);
            if(cur_token != null){
                mssBuilder.append(", Lexema: ");
                mssBuilder.append(cur_token.value);
            }

            if(message != null){
                mssBuilder.append(", Info: ");
                mssBuilder.append(message);
            }
            
            syntaxErrors.add(mssBuilder.toString());
        } catch (Exception e){
            syntaxErrors.add(message);
        }
    }


    public void unrecovered_syntax_error(Symbol cur_token) {
        syntaxErrors.add("Errores de sintaxis severos detectados, revisa municiosamente el codigo");
    }
:}

/*---------------------------------------
             Declarations
-----------------------------------------*/
/* Terminals (tokens returned by the scanner). */
terminal    PLUS, MINUS, TIMES, DIV, MODULE, POWER,
            SEMICOLON, COLON, COMMA, DOT,
            LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK,
            GRATER, LESS, GRATER_EQUALS, LESS_EQUALS,

            JAVA_SECTION, PASCAL_SECTION, MAIN_SECTION,

            AND,
            ARRAY,
            BEGIN,
            BOOLEAN_TKN,
            BREAK,
            CASE,
            CHAR_INPUT,
            CHAR_TKN,
            CLASS,
            CLEAR,
            CONST,
            CONTINUE,
            DEFAULT,
            DO,
            DOWNTO,
            ELSE,
            END,
            EQUALS,
            EXTENDS,
            FLOAT_INPUT,
            FLOAT_TKN,
            FOR,
            FUNCTION,
            GETCH,
            HASH,
            IF,
            IN,
            INCLUDE,
            INT_INPUT,
            INT_TKN,
            JAVA,
            MAIN,
            NEW,
            NOT,
            NULL_LIT,
            OF,
            OR,
            PACKED,
            PASCAL,
            PRINT,
            PRINTLN,
            PRINTF,
            PRIVATE,
            PROCEDURE,
            PROGRAM,
            PROTECTED,
            PUBLIC,
            REAL_TKN,
            RECORD,
            REPEAT,
            RETURN,
            SCANF,
            SET,
            STRING_TKN,
            SUPER,
            SWITCH,
            THEN,
            THIS,
            TO,
            TYPE,
            UNTIL,
            VAR,
            VOID,
            WHILE,
            WITH,

            ASSIGNATION,
            DIFFERENT,
            AMPERSAND,
            MOD,

            UMINUS,

            BARRA
            ;
terminal String     ID, STRING_LIT;
terminal Character  CHAR_LIT;
terminal Integer    INTEGER_LIT;
terminal boolean    BOOLEAN_LIT;
terminal float      FLOAT_LIT;


/*----------------------------- Non-terminals ---------------------------------------*/
non terminal        s;

/******************************* FOR PASCAL ****************************/
non terminal List<DefAst> pascal_block, pcontent, 
                    procedure_b, procedures, 
                    functions_b, functions
                    ;
non terminal List<Label> id_list
                    ;
non terminal Label var_type
                    ;
non terminal List<DefAst> 
                    list_vardec, var_b, var_dec
                    ;
non terminal Expression expression, bool_exp, arit_exp, literals
                    ;
non terminal InitIf if_stmt
                    ;
non terminal List<Expression> expression_list,
                    labels
                    ;
non terminal Range range, arr_range
                    ;
non terminal Statement simple_stmt, complex_stmt, 
                    complex_else
                    ;
non terminal List<Statement> list_stmts, more_stmts, block_stmt, statements,
                    block_cond, 
                    case_stmts, case_else_stmts
                    ;
non terminal WhileAst while_stmt
                    ;
non terminal ForAst for_stmt
                    ;
non terminal RepeatAst repeat_stmt
                    ;
non terminal CaseAst case_stmt
                    ;   
non terminal ElseAst else_block
                    ;
non terminal FunctionUseStmt definite_fun
                    ;
non terminal FunctionDec function_dec
                    ;
non terminal ProcedureDec procedure_dec
                    ;
non terminal List<Argument> arguments, type_arg
                    ;
non terminal PassIf elif, conditional
                    ;
non terminal List<SimpleCase> case_block
                    ;

/******************************* FOR JAVA ****************************/

non terminal jbrack
    ;
non terminal List<JClass> java_block, jcontent
    ;
non terminal JClass jclass
    ;
non terminal AccessMod jmodificator
    ;
non terminal Label jherence
    ;
non terminal List<JDef> jinternal_block
    ;
non terminal JDef jinternal
    ;
non terminal Typable joptions_dec
    ;
non terminal List<JArg> jargs, jlist_args
    ;
non terminal List<Statement> jstmts_block
    ;
non terminal Statement jstmt, jfor_reduced_stmt,
        jcontrol_stmts,
        jsimple_stmts
    ;
non terminal JMethod jmethod_dec
    ;
non terminal JType jtype
    ;
non terminal Index jbracks_list
    ;
non terminal JArg jarg
    ;
non terminal JWhileAst jwhile_stmt
    ;
non terminal JDoWhileAst jdo_while_stmt
    ;
non terminal JForAst jfor_stmt
    ;
non terminal JSwitchAst jswitch_stmt
    ;
non terminal List<JCase> jswitch_cases
    ;
non terminal JCase jcase
    ;
non terminal JPassIf jif_stmt, jelif_stmt
    ;
non terminal JAssignAst jassign
    ;
non terminal JLiteral jliterals
    ;
non terminal Expression jarit_exp, jbool_exp, jexp, jinput_func
    ;
non terminal List<Expression> jexp_list, jarray_access
    ;
non terminal JDefiniteFunc jdefinite_funcs
    ;
non terminal List<JInvocation> jaccess
    ;
non terminal JInvocation jcomplex_access
    ;
non terminal JDeclaration jdeclaration
    ;
non terminal JMethodUseStmt jmethod_use
    ;
non terminal JConstructUse jconstruct_use
    ;

/********************** FOR MAIN PROGRAM (C) ****************************/
non terminal c_java_object_array
    ;

non terminal CMain main_program
    ;
non terminal PrimitiveType ctype
    ;
non terminal List<Label> cimports
    ;
non terminal CExp cexp, cbool_exp, carit_exp
    ;
non terminal CForAst cfor_stmt
    ;
non terminal CWhileAst cwhile_stmt
    ;
non terminal CDoWhile cdo_while_stmt
    ;
non terminal CSwitchAst cswitch_stmt
    ;
non terminal List<CCase> ccases
    ;
non terminal CCase ccase
    ;
non terminal List<CStatement> cstmts
    ;
non terminal List<JInvocation> c_jinvocation
    ;
non terminal CStatement cfor_reduced_stmt, cstmt, cdef_functions_stmt, 
    ccontrol_stmts
    ;
non terminal List<CExp> carray_dims, cparams
    ;
non terminal CLiteral cliterals
    ;
non terminal List<CConstDec> cconst_b
    ;
non terminal List<DefAst> cvars_b
    ;
non terminal DefAst cvars_dec
    ;
non terminal CObjectDec c_j_construct
    ;
non terminal List<CObjectDec> c_java_construct, c_jclass_init
    ;
non terminal CSimpleStmt csingle_stmt
    ;
non terminal CMethodPass c_pinvocation
    ;
non terminal CPassIf cif_stmt, celif_stmt
    ;
non terminal CAssign cassign
    ;


/*------------------------------------------------------------------------------
                                 Precedences
--------------------------------------------------------------------------------*/

/*booleanos*/
precedence left THEN;
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;

/*operaciones*/
precedence left PLUS, MINUS;
precedence left TIMES, DIV, BARRA, MOD;
precedence left POWER;
precedence right UMINUS;

precedence right SEMICOLON;

precedence left IF;
precedence left ELSE;

/* --------------------------------------
            The grammar 
-----------------------------------------*/
start with s;
s ::=   pascal_block:pb
        java_block:jb
        main_program:cb
            {:
                analyzator.pascalSemanticAnalysis(pb);
                analyzator.javaSemanticAnalysis(jb);
                analyzator.mainCSemanticAnalysis(cb);
            :}
    ;

/* --------------------------------------------------------------------------------------------------
                                            PASCAL
-----------------------------------------------------------------------------------------------------*/
pascal_block ::= PASCAL_SECTION pcontent:l
            {:
                RESULT = l;
            :}
        ;

pcontent ::= functions_b:lf procedure_b:lp
            {:
                if(lf != null && lp != null){
                    lf.addAll(lp);
                    RESULT = lf;
                } else if (lf != null){
                    RESULT = lf;
                } else if (lp != null){
                    RESULT = lp;
                } else {
                    RESULT = new LinkedList<>();
                }
            :}
        ;
/*-------------------------------------- UTILITIES --------------------------------*/
var_type ::= INT_TKN:t  
                    {: 
                        RESULT = new Label(
                            PrimitiveType.IntegerPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | FLOAT_TKN:t    
                    {: 
                        RESULT = new Label(
                            PrimitiveType.RealPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | BOOLEAN_TKN:t 
                    {: 
                        RESULT = new Label(
                            PrimitiveType.BooleanPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | CHAR_TKN:t    
                    {: 
                        RESULT = new Label(
                            PrimitiveType.CharPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | STRING_TKN:t  
                    {: 
                        RESULT = new Label(
                            PrimitiveType.StringPT.getName(), 
                            new Position(tleft, tright)
                        ); 
                    :}
            | ID:t  
                    {: 
                        RESULT = new Label(
                            t, 
                            new Position(tleft, tright)
                        ); 
                    :}
            | error
            ;

id_list ::= id_list:l COMMA ID:i
                    {:
                        if(l != null){
                            l.add(new Label(i, new Position(ileft, iright)));
                        } else {
                            l = new ArrayList<>();
                        }
                        RESULT = l;
                    :}

            | ID:i      
                    {:
                        List<Label> list = new ArrayList<>();
                        list.add(new Label(i, new Position(ileft, iright)));
                        RESULT = list;
                    :}
            ;

range ::= expression:e1 DOT DOT DOT expression:e2
                    {:
                        RESULT = new Range(e1, e2);
                    :}
            ;

arr_range ::= LBRACK expression:e1 DOT DOT expression:e2 RBRACK
                    {:
                         RESULT = new Range(e1, e2);
                    :}
            ;

expression_list ::= expression_list:l COMMA expression:e
                    {:
                        if(l != null){
                            l.add(e);
                        } else {
                            l = new LinkedList<>();
                        }
                        RESULT = l;
                    :}
            | expression:e
                    {:
                        LinkedList<Expression> list = new LinkedList<Expression>();
                        list.add(e);
                        RESULT = list;
                    :}
            ;


/*-------------------------------------- VARIABLES BLOCK -------------------------------*/
var_b ::= VAR list_vardec:l
                    {:
                        RESULT = l;
                    :}
            | /* emtpy */
                    {:
                        RESULT = new LinkedList<DefAst>();
                    :}
            ;

list_vardec ::= list_vardec:l var_dec:dl SEMICOLON
                    {:
                        try{
                            l.addAll(dl);
                        } catch (NullPointerException e){}    
                        RESULT = l;
                    :}
            | var_dec:l SEMICOLON
                    {:
                        RESULT = l;
                    :}  
        /*ERROR MANAGE*/
            | list_vardec:l var_dec:dl error var_dec
                    {:
                        try{
                            l.addAll(dl);
                        } catch (NullPointerException e){}    
                        RESULT = l;
                    :}
            | error var_dec:l
                    {:
                        RESULT = l;
                    :} 
            | var_dec:l error var_dec
                    
            ;

var_dec ::= id_list:l COLON var_type:t 
                    {:
                        RESULT = genTypeTab.userDef(l, t);
                    :}
            | id_list:l COLON ARRAY arr_range:r OF var_type:t 
                    {:
                        RESULT = genTypeTab.arrayDef(l, t, r);
                    :}
        /*MANAGE ERRORS*/
            | id_list:l error var_type:t 
                    {:
                        RESULT = genTypeTab.userDef(l, t);
                    :}
            | id_list:l error range:r 
                    {:
                        RESULT = genTypeTab.rangeDef(l, r);
                    :}
            | id_list:l error ARRAY arr_range:r OF var_type:t 
                    {:
                        RESULT = genTypeTab.arrayDef(l, t, r);
                    :}
            ;


/*---------------------------------- EXPRESSION BLOCK -------------------------------------*/

expression ::= expression:e1 AND:o expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.And, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 AND:o THEN expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.AndThen, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 OR:o expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Or, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | expression:e1 OR:o ELSE expression:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.OrElse, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | NOT:o expression:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Not,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
            | bool_exp:e
                    {:
                        RESULT = e;
                    :}
            ;

bool_exp ::= arit_exp:e1 EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.EqualsTo, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 DIFFERENT:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.DifferentTo, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 GRATER:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.GraterThan, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 LESS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.LessThan, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 GRATER_EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.GraterEq, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 LESS_EQUALS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.LessEq, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e
                    {:
                        RESULT = e;
                    :}
            ;

arit_exp ::= 
        /*MANAGE ERRORS*/
                error PLUS error
            | error MINUS error
            | error TIMES error
            | error DIV error
            | error BARRA error
            | error MOD error
            | arit_exp:e1 PLUS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Addition, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 MINUS:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Substraction, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 TIMES:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Multiplication, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 DIV:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Division, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 MOD:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Module, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | arit_exp:e1 POWER:o arit_exp:e2
                    {:
                        RESULT = new Operation(
                            DefiniteOperation.Power, e1, e2,
                            new Position(oleft, oright)
                        );
                    :}
            | literals:e
                    {:
                        RESULT = e;
                    :}
            | ID:i LBRACK arit_exp:e RBRACK
                    {:
                        RESULT = new VectorUse(
                            i, e, new Position(ileft, iright)
                        );
                    :}
            | ID:i LPAREN expression_list:l RPAREN
                    {:
                        RESULT = new FunctionUse(
                            i, l, new Position(ileft, iright)
                        );
                    :}
            | ID:i LPAREN RPAREN
                    {:
                        RESULT = new FunctionUse(
                            i, new Position(ileft, iright)
                        );
                    :}
            | ID:i
                    {:
                        RESULT = new SingleExp(
                            i, new Position(ileft,iright)
                        );
                    :}
            %prec UMINUS
            | LPAREN expression:e RPAREN
                    {:
                        RESULT = e;
                    :}
            %prec UMINUS
            | PLUS:o arit_exp:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Addition,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
            %prec UMINUS
            | MINUS:o arit_exp:e
                    {:
                        RESULT = new UnaryOperation(
                            DefiniteOperation.Substraction,
                            e,
                            new Position(oleft, oright)
                        );
                    :}
        /*MANAGE ERRORS*/
            %prec UMINUS
            | LPAREN error RPAREN
            %prec UMINUS        
            | MINUS error
            %prec UMINUS
            | PLUS error
            ;

literals ::= BOOLEAN_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.BooleanPT, 
                            l,
                            new Position(lleft, lright)
                        );
                    :}
            | INTEGER_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.IntegerPT, 
                            l,
                            new Position(lleft, lright)
                        );
                    :}
            | FLOAT_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.RealPT, 
                            new Position(lleft, lright)
                        );
                    :}
            | CHAR_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.CharPT, 
                            l,
                            new Position(lleft, lright)
                        );
                    :}
            | STRING_LIT:l
                    {:
                        RESULT = new SingleExp(
                            PrimitiveType.StringPT, 
                            new Position(lleft, lright)
                        );
                    :}
            ;


/*------------------------------------------- STATEMENTS BLOCK ------------------------------*/

/************************* conditionals *****************************/
conditional ::=
          if_stmt:i block_cond:ls
                {:
                    RESULT = new PassIf(new IfAst(
                        i.getExpression(), 
                        ls, 
                        i.getPosition()
                    ));
                :}
        | if_stmt:i block_cond:ls SEMICOLON
                {:
                    RESULT = new PassIf(new IfAst(
                        i.getExpression(), 
                        ls,
                        i.getPosition()
                    ));
                :}
        | if_stmt:i block_cond:ls ELSE:e elif:pi
                {:  
                    if(pi.getElseAst() != null && pi.getElseAst().getInitPos() == null){
                        pi.getElseAst().setInitPos(
                            new Position(eleft, eright)
                        );
                    }
                    RESULT = astGen.genPassIf(
                        pi, 
                        new IfAst(i.getExpression(), ls, i.getPosition())
                    );
                :}
        ;

if_stmt ::= IF:i LPAREN expression:e RPAREN THEN
                {:  
                    RESULT = new InitIf(e, new Position(ileft, iright));     
                :}
        | IF:i LPAREN error RPAREN THEN
                {:  
                    RESULT = new InitIf(null, new Position(ileft, iright));     
                :}
    /*MANAGE ERRORS*/
        | IF:i LPAREN expression:e error THEN
                {:  
                    RESULT = new InitIf(e, new Position(ileft, iright));     
                :}
        | IF:i error expression:e RPAREN THEN
                {:  
                    RESULT = new InitIf(e, new Position(ileft, iright));     
                :}
        | IF:i error expression:e error THEN
                {:  
                    RESULT = new InitIf(e, new Position(ileft, iright));     
                :}
        ;
block_cond ::= simple_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | BEGIN block_stmt:ls END
                {:
                    RESULT = ls;
                :}
        ;
elif ::= else_block:e SEMICOLON
                {:
                    RESULT = new PassIf(e);
                :}
        | conditional:pi
                {:
                    RESULT = pi;
                :}
        ;

else_block ::= complex_else:s
                {:  
                    RESULT = new ElseAst(astGen.oneStmtInList(s)); 
                :}
        | simple_stmt:s
                {:
                    RESULT = new ElseAst(astGen.oneStmtInList(s)); 
                :}
        | BEGIN block_stmt:ls END
                {:
                    RESULT = new ElseAst(ls);
                :}
        ;

complex_else ::= case_stmt:s
                {:  RESULT = s; :}
        | while_stmt:s
                {:  RESULT = s; :}
        | for_stmt:s
                {:  RESULT = s; :}
        | repeat_stmt:s
                {:  RESULT = s; :}
        ;

/************************* case *****************************/

case_stmt ::= CASE:c LPAREN expression:e RPAREN OF case_block:lsc 
                    ELSE case_else_stmts:ls END SEMICOLON
                {:
                    RESULT = new CaseAst(e, lsc, new ElseAst(ls), new Position(cleft, cright));
                :}
        ;

case_block ::= case_block:l labels:labs COLON case_stmts:ls SEMICOLON
                {:
                    if(l != null){
                        l.add(new SimpleCase(labs, ls));
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | labels:labs COLON case_stmts:ls SEMICOLON
                {:
                    RESULT = astGen.genSimpleCaseList(labs, ls);
                :}
        ;

labels ::= labels:l COMMA expression:e
                {:
                    if(l != null){
                        l.add(e);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | expression:e
                {:
                    LinkedList<Expression> list = new LinkedList<>();
                    list.add(e);
                    RESULT = list;
                :}
        ;

case_stmts ::= simple_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | BEGIN block_stmt:l END
                {:
                    RESULT = l;
                :}
        ;

case_else_stmts ::= simple_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s SEMICOLON
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | BEGIN block_stmt:l
                {:      
                    RESULT = l;
                :}
        ;

/************************* ciclos *****************************/

while_stmt ::= WHILE:w LPAREN expression:e RPAREN DO statements:l
                {:
                    RESULT = new WhileAst(e, l, new Position(wleft, wright));
                :}
        | WHILE:w LPAREN error RPAREN DO statements:l
                {:
                    RESULT = new WhileAst(null, l, new Position(wleft, wright));
                :}
        ;

for_stmt ::= FOR:f ID:i ASSIGNATION expression:e1 TO expression:e2 DO statements:l
                {:
                    Range range = new Range(e1, e2);
                    Label variable = new Label(i, new Position(ileft, iright));
                    RESULT = new ForAst(variable, range, l, new Position(fleft, fright));
                :}
        | FOR:f ID:i ASSIGNATION error TO expression:e2 DO statements:l
                {:
                    Range range = new Range(null, e2);
                    Label variable = new Label(i, new Position(ileft, iright));
                    RESULT = new ForAst(variable, range, l, new Position(fleft, fright));
                :}
        | FOR:f ID:i error expression:e1 TO expression:e2 DO statements:l
                {:
                    Range range = new Range(e1, e2);
                    Label variable = new Label(i, new Position(ileft, iright));
                    RESULT = new ForAst(variable, range, l, new Position(fleft, fright));
                :}
        ;

repeat_stmt ::= REPEAT:r statements:l UNTIL expression:e
                {:
                    RESULT = new RepeatAst(e, l, new Position(rleft, rright));
                :}
        ;

/************************* statements *****************************/
statements ::= simple_stmt:s SEMICOLON
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | BEGIN block_stmt:l END SEMICOLON
                {:
                    RESULT = l;
                :}
        ;

block_stmt ::= list_stmts:l
                {:  RESULT = l; :}
        | /* empty */
                {:
                    RESULT = new LinkedList<Statement>();
                :}
        ;

list_stmts ::= simple_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s SEMICOLON
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s SEMICOLON more_stmts:l
                {:
                    if(l != null){
                        l.add(0, s);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | complex_stmt:s more_stmts:l
                {:
                    if(l != null){
                        l.add(0, s);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        ;

more_stmts ::= 
          simple_stmt:s error
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s SEMICOLON
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        | simple_stmt:s SEMICOLON more_stmts:l
                {:
                    if(l != null){
                        l.add(0, s);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | complex_stmt:s more_stmts:l
                {:
                    if(l != null){
                        l.add(0, s);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | complex_stmt:s
                {:
                    RESULT = astGen.oneStmtInList(s);
                :}
        ;

simple_stmt ::= BREAK:b
                {:  
                    RESULT = new SimpleStmt(
                        SimpleStmt.BREAK, 
                        new Position(bleft, bright)
                    );  
                :}
        | CONTINUE:c
                {:  
                    RESULT = new SimpleStmt(
                        SimpleStmt.CONTINUE,
                        new Position(cleft, cright)
                    );  
                :}
        | ID:i ASSIGNATION expression:e
                {:  
                    RESULT = new Assignation(
                        new Label(i, new Position(ileft, iright)), e
                    );
                :}
        | ID:i LPAREN expression_list:el RPAREN
                {:
                    RESULT = new FunctionUseStmt(
                        new Label(i, new Position(ileft, iright)),
                        el
                    );
                :}
        | ID:i LPAREN RPAREN
                {:
                    RESULT = new FunctionUseStmt(
                        new Label(i, new Position(ileft, iright)),
                        new LinkedList<>()
                    );
                :}
        | ID:i LBRACK expression:e1 RBRACK ASSIGNATION expression:e2
                {:
                    RESULT = new ArrayAssign(
                        new Label(i, new Position(ileft, iright)),
                        e1,
                        e2
                    );
                :}
        | definite_fun:fu
                {: RESULT = fu; :} 
        | error
        ; 

complex_stmt ::= conditional:pi
                {:  
                    RESULT =  astGen.transformPassIf(pi); 
                :}
        | case_stmt:s
                {:  RESULT = s; :}
        | while_stmt:s
                {:  RESULT = s; :}
        | for_stmt:s
                {:  RESULT = s; :}
        | repeat_stmt:s
                {:  RESULT = s; :}
        ;

/*-------------------- FUNCTIONS -------------------------*/

functions_b ::= functions:l
                {:
                    RESULT = l;
                :}
        | /* empty */
                {:
                    RESULT = new LinkedList<>();
                :}
        ;

functions ::= functions:l function_dec:d
                {:
                    if(l != null){
                        l.add(d);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | function_dec:d
                {:
                    LinkedList<DefAst> list = new LinkedList<>();
                    list.add(d);
                    RESULT = list;
                :}
        ;

function_dec ::= FUNCTION ID:i LPAREN arguments:a RPAREN COLON var_type:t SEMICOLON
            var_b:lv
            BEGIN block_stmt:ls END SEMICOLON
                {:  
                    RESULT = new FunctionDec(
                        new Label(i, new Position(ileft, iright)),
                        t, a, lv, ls
                    );
                :}
        ;

/*-------------------------------------- PROCEDURES ----------------------------------*/

procedure_b ::= procedures:p
                {:
                    RESULT = p;
                :} 
        | /* empty */
                {:  
                    RESULT = new LinkedList<>();
                :}
        ;

procedures ::= procedures:l procedure_dec:d
                {:
                    if(l != null){
                        l.add(d);
                    } else {
                        l = new LinkedList<>();
                    }
                    RESULT = l;
                :}
        | procedure_dec:d
                {:
                    LinkedList<DefAst> list = new LinkedList<>();
                    list.add(d);
                    RESULT = list;
                :}
        ;

procedure_dec ::= PROCEDURE ID:i LPAREN arguments:a RPAREN SEMICOLON
            var_b:lv
            BEGIN block_stmt:ls END SEMICOLON
                {:
                    RESULT = new ProcedureDec(
                        new Label(i, new Position(ileft, iright)),
                        a, lv, ls
                    );
                :}
        ;

/*---------------------------------- PARAMS / ARGUMENTS ----------------------------------*/
arguments ::= arguments:l COMMA type_arg:args
                {:
                    try{
                        l.addAll(args);
                    } catch (NullPointerException e){

                    }
                    
                    RESULT = l;
                :}
        | type_arg:args
                {:
                    RESULT = args;
                :}
        | /* empty */
                {:
                    RESULT = new LinkedList<Argument>();
                :}
        ;

type_arg ::= VAR id_list:l COLON var_type:t
                {:
                    RESULT = astGen.generateArgs(l, t, true);
                :}
        | id_list:l COLON var_type:t
                {:
                    RESULT = astGen.generateArgs(l, t, false);
                :}
        ;


/* --------------------------------------------------------------------------------------------------
                                            JAVA
-----------------------------------------------------------------------------------------------------*/
java_block ::= JAVA_SECTION jcontent:lc
            {:
                RESULT = lc;
            :}
        ;

/*-------------------------UTIL----------------------------*/
jmodificator ::= PUBLIC
            {: 
                RESULT = AccessMod.PUBLIC; 
            :}
        | PRIVATE
            {: 
                RESULT = AccessMod.PRIVATE; 
            :}
        | PROTECTED
            {: 
                RESULT = AccessMod.PROTECTED; 
            :}
        ;

jtype ::= INT_TKN:t jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label(
                        PrimitiveType.IntegerPT.getName(), 
                        new Position(tleft, tright)
                    ),
                    JReferType.PrimitiveData,
                    i.getNumber()
                );
            :}
        | STRING_TKN:t jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label(
                        PrimitiveType.StringPT.getName(), 
                        new Position(tleft, tright)
                    ),
                    JReferType.PrimitiveData,
                    i.getNumber()
                );
            :}
        | FLOAT_TKN:t jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label(
                        PrimitiveType.RealPT.getName(), 
                        new Position(tleft, tright)
                    ),
                    JReferType.PrimitiveData,
                    i.getNumber()
                );
            :}
        | BOOLEAN_TKN:t jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label(
                        PrimitiveType.BooleanPT.getName(), 
                        new Position(tleft, tright)
                    ),
                    JReferType.PrimitiveData,
                    i.getNumber()
                );
            :}
        | CHAR_TKN:t jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label(
                        PrimitiveType.CharPT.getName(), 
                        new Position(tleft, tright)
                    ),
                    JReferType.PrimitiveData,
                    i.getNumber()
                );
            :}
        | ID:id jbracks_list:i
            {:
                RESULT = new JArrayType(
                    new Label( id, new Position(idleft, idright)),
                    JReferType.ObjectReference,
                    i.getNumber()
                );
            :}
        | INT_TKN:t
            {:
                RESULT = new JType(
                    JReferType.PrimitiveData,
                    new Label(
                        PrimitiveType.IntegerPT.getName(), 
                        new Position(tleft, tright)
                    )
                );
            :}
        | STRING_TKN:t
            {:
                RESULT = new JType(
                    JReferType.PrimitiveData,
                    new Label(
                        PrimitiveType.StringPT.getName(), 
                        new Position(tleft, tright)
                    )
                );
            :}
        | FLOAT_TKN:t
            {:
                RESULT = new JType(
                    JReferType.PrimitiveData,
                    new Label(
                        PrimitiveType.RealPT.getName(), 
                        new Position(tleft, tright)
                    )
                );
            :}
        | BOOLEAN_TKN:t
            {:
                RESULT = new JType(
                    JReferType.PrimitiveData,
                    new Label(
                        PrimitiveType.BooleanPT.getName(), 
                        new Position(tleft, tright)
                    )
                );
            :}
        | CHAR_TKN:t
            {:
                RESULT = new JType(
                    JReferType.PrimitiveData,
                    new Label(
                        PrimitiveType.CharPT.getName(), 
                        new Position(tleft, tright)
                    )
                );
            :}
        | ID:id
            {:
                RESULT = new JType(
                    JReferType.ObjectReference,
                    new Label(id, new Position(idleft, idright))
                );
            :}
        ;

jbracks_list ::= jbracks_list:i jbrack
            {:
                i.increment();
                RESULT = i;
            :}
        | jbrack
            {:
                RESULT = new Index();
            :}
        ;

jbrack ::= LBRACK RBRACK
        ;

jarray_access ::= LBRACK jexp:e RBRACK
            {:
                List<Expression> list = new LinkedList<>();
                list.add(e);
                RESULT = list;
            :}
        | jarray_access:l LBRACK jexp:e RBRACK
            {:
                l.add(e);
                RESULT = l;
            :}
        ;

jexp_list ::= jexp_list:l COMMA jexp:e
            {:
                l.add(e);
                RESULT = l;
            :}
        | jexp:e
            {:
                List<Expression> list = new LinkedList<>();
                list.add(e);
                RESULT = list;
            :}
        ;

jliterals ::= INTEGER_LIT:o
            {:
                RESULT = new JLiteral(
                    new Position(oleft, oright),
                    o
                );
            :}
        | STRING_LIT:o
            {:
                RESULT = new JLiteral(
                    new Position(oleft, oright),
                    o
                );
            :}
        | BOOLEAN_LIT:o
            {:
                RESULT = new JLiteral(
                    new Position(oleft, oright),
                    o
                );
            :}
        | CHAR_LIT:o
            {:
                RESULT = new JLiteral(
                    new Position(oleft, oright),
                    o
                );
            :}
        | FLOAT_LIT:o
            {:
                RESULT = new JLiteral(
                    new Position(oleft, oright),
                    o
                );
            :}
        ;

/*-------------------------CLASES----------------------------*/
jcontent ::= jcontent:l jclass:c
            {:
                l.add(c);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

jclass ::= PUBLIC CLASS ID:id jherence:h LBRACE jinternal_block:ld RBRACE
            {:
                Position initPos = new Position(idleft, idright);
                h = h != null ? h : new Label(JClass.FATHER_OBJECT_CLASS, initPos);
                RESULT = new JClass(
                    new Label(id, initPos),
                    h, ld
                );
            :}
        ;

jherence ::= EXTENDS ID:id
            {:
                RESULT = new Label(
                    id, 
                    new Position(idleft, idright)
                );
            :}
        | /* empty */
            {:
                RESULT = null;
            :}
        ;

/*-------------------------METHODS AND FIELDS----------------------------*/
jinternal_block ::= jinternal_block:l jinternal:d
            {:
                l.add(d);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

jinternal ::= 
        /* declarations */
        jmodificator:a jtype:t ID:id joptions_dec:d
            {:
                d.defineType(t);
                JDef jdef = (JDef) d;
                jdef.setAccess(a);
                jdef.setName(new Label(id, new Position(idleft, idright)));
                RESULT = jdef;
            :}
        /* void method */
        | jmodificator:a VOID ID:id jmethod_dec:m
            {:
                m.setAccess(a);
                m.setName(new Label(id, new Position(idleft, idright)));
                m.setType(new JType());
                RESULT = m;
            :}
        /* constructor */
        | jmodificator:m ID:id LPAREN jargs:la RPAREN LBRACE jstmts_block:ls RBRACE
            {:
                RESULT = new JConstructor(
                    new Label(id, new Position(idleft, idright)),
                    m, la, ls
                );
            :}
        ;

joptions_dec ::= 
        /*simple field*/
        SEMICOLON
            {:
                RESULT = new JField();
            :}
        /*simple and declaration field*/
        | ASSIGNATION jexp:e SEMICOLON
            {:
                JField field = new JField();
                field.setExpAssign(e);
                RESULT = field;
            :}
        /*method*/
        | jmethod_dec:m
            {:
                RESULT = m;
            :}
        ;

jmethod_dec ::= LPAREN jargs:la RPAREN LBRACE jstmts_block:ls RBRACE
            {:
                RESULT = new JMethod(null, null, la, ls);
            :}
        ;


/*---------------------------------- ARGS --------------------------------*/

jargs ::= jlist_args:l
            {:
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

jlist_args ::= jlist_args:l COMMA jarg:a
            {:
                l.add(a);
                RESULT = l;
            :}
        | jarg:a
            {:
                List<JArg> list = new LinkedList<>();
                list.add(a);
                RESULT = list;
            :}
        ;

jarg ::= jtype:t ID:id
            {:
                RESULT = new JArg(
                    t, new Label(id, new Position(idleft, idright))
                );
            :}
        ;

/*--------------------------- STATEMENTS -----------------------------------*/

jstmts_block ::= jstmts_block:l jstmt:s
            {:
                l.add(s);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

jstmt ::= jcontrol_stmts:s
            {: RESULT = s; :}
        | jsimple_stmts:s SEMICOLON
            {: RESULT = s; :}
        | jdeclaration:s SEMICOLON
            {: RESULT = s; :}
        | jmethod_use:s SEMICOLON
            {: RESULT = s; :}
        | jconstruct_use:s SEMICOLON
            {: RESULT = s; :}
        | jassign:s SEMICOLON
            {: RESULT = s; :}
        | jdefinite_funcs:s SEMICOLON
            {: RESULT = s; :}
        ;

jcontrol_stmts ::= jif_stmt:pi
            {:
                RESULT = astGen.transformPassJIf(pi);
            :}
        | jwhile_stmt:s
            {: RESULT = s; :}
        | jdo_while_stmt:s
            {: RESULT = s; :}
        | jfor_stmt:s
            {: RESULT = s; :}
        | jswitch_stmt:s
            {: RESULT = s; :}
        ;

jsimple_stmts ::= BREAK:s
            {:
                RESULT = new JSimpleStmt(
                    new Position(sleft, sright), true
                );
            :}
        | CONTINUE:s
            {:
                RESULT = new JSimpleStmt(
                    new Position(sleft, sright), false
                );
            :}
        | RETURN:s jexp:pe
            {:
                RESULT = new JReturnStmt(
                    new Position(sleft, sright), pe
                );
            :}
        ; 

jdefinite_funcs ::= PRINT:p LPAREN jexp_list:lpe RPAREN
            {:
                RESULT = new JDefiniteFunc(
                    new Position(pleft, pright), lpe, false
                );
            :}
        | PRINTLN:p LPAREN jexp_list:lpe RPAREN
            {:
                RESULT = new JDefiniteFunc(
                    new Position(pleft, pright), lpe, true
                );
            :}
        ;

/************************** CONDITIONAL *************************/

jif_stmt ::= IF:i LPAREN jexp:e RPAREN LBRACE jstmts_block:ls RBRACE jelif_stmt:pi
            {:
                RESULT = astGen.generateJPassIf(
                    pi,
                    new JIfAst(
                        new Position(ileft, iright),
                        e, ls
                    )
                );
            :}
        ;

jelif_stmt ::= ELSE:e LBRACE jstmts_block:ls RBRACE
            {:
                JElseAst elseStmt = new JElseAst(
                    new Position(eleft, eright),
                    ls
                );
                RESULT = new JPassIf(elseStmt);
            :}
        | ELSE jif_stmt:pi
            {:
                RESULT = pi;
            :}
        | /* empty */
            {:
                RESULT = new JPassIf();
            :}
        ;

/**************************** CICLOS ****************************/

jwhile_stmt ::= WHILE:w LPAREN jexp:e RPAREN LBRACE jstmts_block:ls RBRACE
            {:
                RESULT = new JWhileAst(
                    new Position(wleft, wright),
                    e, ls
                );
            :}
        ;

jdo_while_stmt ::= DO:d LBRACE jstmts_block:ls RBRACE WHILE LPAREN jexp:e RPAREN SEMICOLON
            {:
                RESULT = new JDoWhileAst(
                    new Position(dleft, dright),
                    e, ls
                );
            :}
        ;   

jfor_stmt ::= FOR:f RPAREN jfor_reduced_stmt:s1 SEMICOLON jexp:e SEMICOLON jfor_reduced_stmt:s2 RPAREN 
              LBRACE jstmts_block:ls RBRACE
            {:
                RESULT = new JForAst(
                    new Position(fleft, fright),
                    s1, e, s2, ls
                );
            :}
        ;

jfor_reduced_stmt ::= 
          jdeclaration:s    {: RESULT = s;    :}
        | jmethod_use:s     {: RESULT = s;    :}        
        | jassign:s         {: RESULT = s;    :}
        | /* empty */       {: RESULT = null; :}
        ;

/****************************** SWITCH **************************/

jswitch_stmt ::= SWITCH:s LPAREN jexp:e RPAREN LBRACE jswitch_cases:lc RBRACE
            {:
                RESULT = new JSwitchAst(
                    new Position(sleft, sright),
                    e, lc
                );
            :}
        ;

jswitch_cases ::= jswitch_cases:l jcase:c
            {:
                l.add(c);
                RESULT = l;
            :}
        | jcase:c
            {:
                List<JCase> list = new LinkedList<>();
                list.add(c);
                RESULT = list;
            :}
        ;

jcase ::= CASE jexp:e COLON jstmts_block:ls
            {:
                RESULT = new JCase(e, ls);
            :}
        | DEFAULT COLON jstmts_block:ls
            {:
                RESULT = new JCase(ls);
            :}
        ;



/****************************** ASSIGNATIONS **************************/
jassign ::= ID:id ASSIGNATION jexp:e 
            {:
                Position initPos = new Position(idleft,idright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        new JVarUse(initPos, id, JContextRef.Local)
                    ),
                    e
                );
            :}
        | THIS:t jaccess:li ASSIGNATION jexp:e 
            {:
                Position initPos = new Position(tleft, tright);
                RESULT = new JAssignAst(
                    new Position(tleft, tright),
                    li, e, JContextRef.FromObject
                );
            :}
        | SUPER:s jaccess:li ASSIGNATION jexp:e
            {:
                RESULT = new JAssignAst(
                    new Position(sleft, sright),
                    li, e, JContextRef.FromFather
                );
            :}
        | ID:i jaccess:li ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JVarUse(initPos, i, JContextRef.Local)
                    ),
                    e
                );
            :}
        | ID:i LPAREN RPAREN jaccess:li ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JMethodUse(initPos, i, JContextRef.Local)
                    ),
                    e
                );
            :}
        | ID:i LPAREN jexp_list:args RPAREN jaccess:li ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JMethodUse(initPos, i, JContextRef.Local, args)
                    ),
                    e
                );
            :}
        | ID:i LPAREN RPAREN jarray_access:ac ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        new JArrayFMUse(initPos, i, JContextRef.Local, ac)
                    ),
                    e
                );
            :}
        | ID:i LPAREN RPAREN jarray_access:ac jaccess:li ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JArrayFMUse(initPos, i, JContextRef.Local, ac)
                    ),
                    e
                );
            :}
        | ID:i LPAREN jexp_list:args RPAREN jarray_access:ac ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        new JArrayFMUse(initPos, i, JContextRef.Local, args, ac)
                    ),
                    e
                );
            :}
        | ID:i LPAREN jexp_list:args RPAREN jarray_access:ac jaccess:li ASSIGNATION jexp:e
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JArrayFMUse(initPos, i, JContextRef.Local, args, ac)
                    ),
                    e
                );
            :}
        | ID:i jarray_access:ac jaccess:li ASSIGNATION jexp:e SEMICOLON
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        li, new JArrayUse(initPos, i, JContextRef.Local, ac)
                    ),
                    e
                );
            :}
        | ID:i jarray_access:ac ASSIGNATION jexp:e SEMICOLON
            {:
                Position initPos = new Position(ileft, iright);
                RESULT = new JAssignAst(
                    initPos,
                    astGen.genListInv(
                        new JArrayUse(initPos, i, JContextRef.Local, ac)
                    ),
                    e
                );
            :}
        ;

/****************************** OTHERS **************************/
jdeclaration ::= jtype:t ID:i ASSIGNATION jexp:pe
            {:
                RESULT = new JDeclaration(
                    new Position(ileft, iright),
                    i, t, pe
                );
            :}
        | jtype:t ID:i
            {:
                RESULT = new JDeclaration(
                    new Position(ileft, iright),
                    i, t
                );
            :}
        ;

jmethod_use ::= THIS:t jaccess:li
            {:
                RESULT = new JMethodUseStmt(
                    new Position(tleft, tright),
                    li, JContextRef.FromObject
                );
            :}
        | SUPER:s jaccess:li
            {:
                RESULT = new JMethodUseStmt(
                    new Position(sleft, sright),
                    li, JContextRef.FromFather
                );
            :}
        | ID:id jaccess:li
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition,
                    astGen.genListInv(
                        li, new JVarUse(initPosition, id, JContextRef.Local)
                    )
                );
            :}
        | ID:id LPAREN RPAREN
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        new JMethodUse(initPosition, id, JContextRef.Local)
                    )
                );
            :}
        | ID:id LPAREN jexp_list:el RPAREN 
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        new JMethodUse(initPosition, id, JContextRef.Local, el)
                    )
                );
            :}
        | ID:id LPAREN RPAREN jaccess:li 
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        li, new JMethodUse(initPosition, id, JContextRef.Local)
                    )
                );
            :}
        | ID:id LPAREN jexp_list:el RPAREN jaccess:li 
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        li, new JMethodUse(initPosition, id, JContextRef.Local, el)
                    )
                );
            :}
        | ID:id LPAREN RPAREN jarray_access:ac jaccess:li
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        li, new JArrayFMUse(initPosition, id, JContextRef.Local, ac)
                    )
                );
            :}
        | ID:id LPAREN jexp_list:args RPAREN jarray_access:ac jaccess:li
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        li, new JArrayFMUse(initPosition, id, JContextRef.Local,args, ac)
                    )
                );
            :}
        | ID:id jarray_access:ac jaccess:li
            {:
                Position initPosition = new Position(idleft, idright);
                RESULT = new JMethodUseStmt(
                    initPosition, 
                    astGen.genListInv(
                        li, new JArrayUse(initPosition, id, JContextRef.Local, ac)
                    )
                );
            :}
        ;

jconstruct_use ::= THIS:t LPAREN RPAREN
            {:
                RESULT = new JConstructUse(
                    new Position(tleft, tright),
                    false
                );
            :}
        | THIS:t LPAREN jexp_list:lpe RPAREN
            {:
                RESULT = new JConstructUse(
                    new Position(tleft, tright),
                    lpe, false
                );
            :}
        | SUPER:s LPAREN RPAREN 
            {:
                RESULT = new JConstructUse(
                    new Position(sleft, sright),
                    true
                );
            :}
        | SUPER:s LPAREN jexp_list:lpe RPAREN 
            {:
                RESULT = new JConstructUse(
                    new Position(sleft, sright),
                    lpe, true
                );
            :}
        ;

jaccess ::= DOT jcomplex_access:i jaccess:l
            {:
                l.add(0, i);
                RESULT = l;
            :}
        | DOT jcomplex_access:i
            {:
                List<JInvocation> list = new LinkedList<>();
                list.add(i);
                RESULT = list;
            :}
        ;

jcomplex_access ::= ID:i
            {:
                RESULT = new JVarUse(
                    new Position(ileft, iright),
                    i, JContextRef.Local
                );
            :}
        | ID:i LPAREN RPAREN 
            {:
                RESULT = new JMethodUse(
                    new Position(ileft, iright),
                    i, JContextRef.Local
                );
            :}
        | ID:i LPAREN RPAREN jarray_access:ac
            {:
                RESULT = new JArrayFMUse(
                    new Position(ileft, iright), 
                    i, JContextRef.Local, ac
                );
            :}
        | ID:i LPAREN jexp_list:el RPAREN
            {:
                RESULT = new JMethodUse(
                    new Position(ileft, iright),
                    i, JContextRef.Local, el
                );
            :}
        | ID:i LPAREN jexp_list:el RPAREN jarray_access:ac
            {:
                RESULT = new JArrayFMUse(
                    new Position(ileft, iright),
                    i, JContextRef.Local, el, ac
                );
            :}
        | ID:i jarray_access:ac
            {:
                RESULT = new JArrayUse(
                    new Position(ileft, iright),
                    i, JContextRef.Local, ac
                );
            :}
        ;


/*------------------------------EXPRESSIONS --------------------------------------*/
jexp ::= jexp:p1 AND:o jexp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.And, 
                    p1, p2
                );
            :}
        | jexp:p1 OR:o jexp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Or, 
                    p1, p2
                );
            :}
        | NOT:o jexp:p
            {:
                RESULT = new JUnaryOp(
                    new Position(oleft, oright),
                    p, DefiniteOperation.Not
                );
            :}
        | jbool_exp:e
            {:
                RESULT = e;
            :}
        ;

jbool_exp ::= jarit_exp:p1 EQUALS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.EqualsTo, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 DIFFERENT:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.DifferentTo, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 GRATER:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.GraterThan, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 LESS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.LessThan, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 GRATER_EQUALS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.GraterEq, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 LESS_EQUALS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.LessEq, 
                    p1, p2
                );
            :}
        | jarit_exp:p
            {:
                RESULT = p;
            :}
        ;

jarit_exp ::= jarit_exp:p1 PLUS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Addition, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 MINUS:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Substraction, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 TIMES:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Multiplication, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 DIV:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Division, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 MOD:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Module, 
                    p1, p2
                );
            :}
        | jarit_exp:p1 POWER:o jarit_exp:p2
            {:
                RESULT = new JOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Power, 
                    p1, p2
                );
            :}
        | jliterals:l
            {:
                RESULT = l;
            :}
        | ID:i jarray_access:ac
            {:
                RESULT = new JInvocationExp(astGen.genListInv(
                    new JArrayUse(
                        new Position(ileft, iright),
                        i, JContextRef.Local, ac
                    )
                ));
                    
            :}
        | ID:i jarray_access:ac jaccess:li
            {:
                RESULT = new JInvocationExp(astGen.genListInv(
                    li,
                    new JArrayUse(
                        new Position(ileft, iright),
                        i, JContextRef.Local, ac
                    )
                ));
            :}
        | ID:i LPAREN jexp_list:args RPAREN
            {:
                RESULT = new JInvocationExp(astGen.genListInv(
                    new JMethodUse(
                        new Position(ileft, iright),
                        i, JContextRef.Local, args
                    )
                ));
            :}
        | ID:i LPAREN RPAREN
            {:
                RESULT = new JInvocationExp(astGen.genListInv(
                    new JMethodUse(
                        new Position(ileft, iright),
                        i, JContextRef.Local
                    )
                ));
            :}
        | ID:i LPAREN jexp_list:l RPAREN jaccess:li
            {:
                
            :}
        | ID:i LPAREN RPAREN jaccess:li
            {:
                
            :}
        | ID:i jaccess:li
            {:
                RESULT = new JInvocationExp(astGen.genListInv(
                    li,
                    new JVarUse(
                        new Position(ileft, iright),
                        i, JContextRef.Local
                    )
                ));
            :}
        | ID:i
            {:
                List<JInvocation> invlist = astGen.genListInv(
                    new JVarUse(
                        new Position(ileft, iright), 
                        i, JContextRef.Local
                    )
                );
                RESULT = new JInvocationExp(invlist);
            :}
        | THIS jaccess:l
            {:
                RESULT = new JInvocationExp(
                    l, JContextRef.FromObject
                );
            :}
        | SUPER jaccess:l
            {:
                RESULT = new JInvocationExp(
                    l, JContextRef.FromFather
                );
            :}
        | NEW:n ID:i LPAREN RPAREN
            {:
                RESULT = new JCreateClassE(
                    new Position(nleft, nright), i
                );
            :}
        | NEW:n ID:i LPAREN jexp_list:el RPAREN
            {:
                RESULT = new JCreateClassE(
                    new Position(nleft, nright), i, el
                );
            :}
        | jinput_func:e
            {:
                RESULT = e;
            :}
        %prec UMINUS
        | LPAREN jexp:e RPAREN
            {:
                RESULT = e;
            :}
        %prec UMINUS
        | PLUS:o jarit_exp:pe
            {:
                RESULT = new JUnaryOp(
                    new Position(oleft, oright), 
                    pe, DefiniteOperation.Addition
                );
            :}
        %prec UMINUS
        | MINUS:o jarit_exp:pe
            {:
                RESULT = new JUnaryOp(
                    new Position(oleft, oright),
                    pe, DefiniteOperation.Substraction
                );
            :}
        ;

jinput_func ::= CHAR_INPUT:i LPAREN RPAREN
            {:
                RESULT = new JInputExp(
                    new Position(ileft, iright),
                    JTypeInput.Char
                );
            :}
        | INT_INPUT:i LPAREN RPAREN
            {:
                RESULT = new JInputExp(
                    new Position(ileft, iright),
                    JTypeInput.Int
                );
            :}
        | FLOAT_INPUT:i LPAREN RPAREN
            {:
                RESULT = new JInputExp(
                    new Position(ileft, iright),
                    JTypeInput.Float
                );
            :}
        ;

/* --------------------------------------------------------------------------------------------------
                                            MAIN (C)
-----------------------------------------------------------------------------------------------------*/
main_program ::=  
        MAIN_SECTION
        cimports:i    
        cconst_b:c
        cvars_b:v
        VOID MAIN LPAREN RPAREN LBRACE cstmts:ls RBRACE
            {:
                RESULT = new CMain(new CImports(i), c, v, ls);
            :}
        ;

/*--------------------------------- UTIL ---------------------------------*/

ctype ::= INT_TKN
            {: RESULT = PrimitiveType.IntegerPT; :}
        | CHAR_TKN
            {: RESULT = PrimitiveType.CharPT; :}
        | FLOAT_TKN
            {: RESULT = PrimitiveType.RealPT; :}
        | STRING_TKN
            {: RESULT = PrimitiveType.StringPT; :}
        | BOOLEAN_TKN
            {: RESULT = PrimitiveType.BooleanPT; :}
        ;

carray_dims ::= carray_dims:l LBRACK cexp:e RBRACK
            {:
                l.add(e);
                RESULT = l;
            :}
        | LBRACK cexp:e RBRACK
            {:
                List<CExp> list = new LinkedList<>();
                list.add(e);
                RESULT = list;
            :}
        ;

cparams ::= cparams:l COMMA cexp:e
            {:
                l.add(e);
                RESULT = l;
            :}
        | cexp:e
            {:
                List<CExp> list = new LinkedList<>();
                list.add(e);
                RESULT = list;
            :}
        ;

cliterals ::= STRING_LIT:l
            {:
                RESULT = new CLiteral(
                    new Position(lleft, lright), l
                );
            :}
        | FLOAT_LIT:l
            {:
                RESULT = new CLiteral(
                    new Position(lleft, lright), l
                );
            :}
        | INTEGER_LIT:l
            {:
                RESULT = new CLiteral(
                    new Position(lleft, lright), l
                );
            :}
        | BOOLEAN_LIT:l
            {:
                RESULT = new CLiteral(
                    new Position(lleft, lright), l
                );
            :}
        | CHAR_LIT:l
            {:
                RESULT = new CLiteral(
                    new Position(lleft, lright), l
                );
            :}
        ;

/*----------------------------- INIT SECTION ----------------------------*/

cimports ::= cimports:l HASH INCLUDE:i STRING_LIT:s
            {:
                Label current = new Label(s, new Position(ileft, iright));
                l.add(current);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

cconst_b ::= cconst_b:l CONST ctype:pt ID:i ASSIGNATION cexp:e SEMICOLON
            {:
                l.add(new CConstDec(
                    new Label(i, new Position(ileft, iright)),
                    pt, e
                ));
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

cvars_b ::= cvars_b:l cvars_dec:d
            {:
                l.add(d);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

cvars_dec ::= ctype:pt ID:i SEMICOLON
            {:
                RESULT = new CVarDec(
                    new Label(i, new Position(ileft, iright)),
                    pt
                );
            :}
        | ctype:pt ID:i ASSIGNATION cexp:e SEMICOLON
            {:
                RESULT = new CVarDec(
                    new Label(i, new Position(ileft, iright)),
                    pt, e
                );
            :}
        | ctype:pt ID:i carray_dims:d SEMICOLON
            {:
                RESULT = new CArrayDec(
                    new Label(i, new Position(ileft, iright)),
                    pt, d
                );
            :}
        | c_jclass_init:cis
            {:
                RESULT = new CObjectsDec(
                    cis
                );
            :}
        ;

c_jclass_init ::= JAVA DOT ID:t c_java_construct:lc SEMICOLON
            {:
                RESULT = astGen.setTypeCObject(
                    lc, new Label(t, new Position(tleft, tright)) 
                );
            :}
        | JAVA DOT ID c_java_object_array
            {:

            :}
        ;

c_java_construct ::= c_j_construct:c COMMA c_java_construct:l
            {:
                l.add(0, c);
                RESULT = l;
            :}
        | c_j_construct:c SEMICOLON
            {:
                List<CObjectDec> list = new LinkedList<>();
                list.add(c);
                RESULT = list;
            :}
        ;

c_j_construct ::= ID:i LPAREN RPAREN
            {:
                RESULT = new CObjectDec(
                    new Label(i, new Position(ileft, iright))
                );   
            :}
        | ID:i LPAREN cparams:le RPAREN
            {:
                RESULT = new CObjectDec(
                    new Label(i, new Position(ileft, iright)), 
                    le
                );
            :}
        ;

c_java_object_array ::= ID carray_dims COMMA c_java_object_array
        | ID carray_dims SEMICOLON
        ;

/*--------------------------- STATEMENTS ---------------------------------*/

cstmts ::= cstmts:l cstmt:s 
            {:
                l.add(s);
                RESULT = l;
            :}
        | /* empty */
            {:
                RESULT = new LinkedList<>();
            :}
        ;

cstmt ::= ccontrol_stmts:s
            {: RESULT = s; :}
        | csingle_stmt:s SEMICOLON
            {: RESULT = s; :}
        | cdef_functions_stmt:s SEMICOLON
            {: RESULT = s; :}
        | c_jinvocation:li SEMICOLON
            {: 
                RESULT = new CObjectInv(li);
            :}
        | c_pinvocation:pi SEMICOLON
            {:
                RESULT = pi.toStmt();
            :}
        | cassign:s SEMICOLON
            {: RESULT = s; :}
        ;

csingle_stmt ::= BREAK:b 
            {:
                RESULT = new CSimpleStmt(
                    new Position(bleft, bright), true
                );
            :}
        | CONTINUE:c
            {:
                RESULT = new CSimpleStmt(
                    new Position(cleft, cright), false
                );
            :}
        ;

cdef_functions_stmt ::=  SCANF:s LPAREN STRING_LIT:m COMMA AMPERSAND ID:v RPAREN 
            {:
                RESULT = new CScanf(
                    new Position(sleft, sright),
                    new Label(m, new Position(mleft, mright)),
                    new Label(v, new Position(vleft, vright))
                );
            :}
        | PRINT:p LPAREN cparams:le RPAREN
            {:
                RESULT = new CPrint(
                    new Position(pleft, pright),
                    le
                );
            :}
        | CLEAR:c LPAREN RPAREN 
            {:
                RESULT = new CDefaultSimpleFun(
                    new Position(cleft, cright),
                    CDefaultSimpleFun.CLEAR_FUN
                );
            :}
        | GETCH:g LPAREN RPAREN
            {:
                RESULT = new CDefaultSimpleFun(
                    new Position(gleft, gright),
                    CDefaultSimpleFun.GETCH_FUN
                );
            :}
        | PRINTF:p LPAREN STRING_LIT:m COMMA AMPERSAND ID:i RPAREN
            {:
                RESULT = new CPrintF(
                    new Position(pleft, pright),
                    new Label(m, new Position(mleft, mright)),
                    new Label(i, new Position(ileft, iright))
                );
            :}
        ;

ccontrol_stmts ::= cif_stmt:pi
            {:
                RESULT = astGen.transformPassCIf(pi);
            :}
        | cswitch_stmt:s
            {: RESULT = s; :}
        | cfor_stmt:s
            {: RESULT = s; :}
        | cwhile_stmt:s
            {: RESULT = s; :}
        | cdo_while_stmt:s
            {: RESULT = s; :}
        ;

cassign ::= c_jinvocation:li ASSIGNATION cexp:e
            {:
                RESULT = new CObjectAssign(
                    new Position(lileft, liright),
                    e, li
                );
            :}
        | ID:i ASSIGNATION cexp:e
            {:
                RESULT = new CVarAssign(
                    new Position(ileft, iright),
                    i, e
                );
            :}
        ;

/************************conditional *************************/

cif_stmt ::= IF:i LPAREN cexp:e RPAREN LBRACE cstmts:ls RBRACE celif_stmt:pi
            {:
                RESULT = astGen.generateCPassIf(
                    pi,
                    new CIfAst(
                        new Position(ileft, iright),
                        e, ls
                    )
                );
            :}
        ;

celif_stmt ::= ELSE cif_stmt:pi
            {:
                RESULT = pi;
            :}
        | ELSE:e LBRACE cstmts:ls RBRACE
            {:
                CElseAst elseStmt = new CElseAst(
                    new Position(eleft, eright),
                    ls
                );
                RESULT = new CPassIf(elseStmt);
            :}
        | /* empty */
            {:
                RESULT = new CPassIf();
            :}
        ;


/************************ switch ********************************/

cswitch_stmt ::= SWITCH:s LPAREN cexp:e RPAREN LBRACE ccases:lc RBRACE
            {:
                RESULT = new CSwitchAst(
                    new Position(sleft, sright),
                    e, lc
                );
            :}
        ;

ccases ::= ccases:l ccase:c
            {:
                l.add(c);
                RESULT = l;
            :}
        | ccase:c
            {:
                List<CCase> list = new LinkedList<>();
                list.add(c);
                RESULT = list;
            :}
        ;

ccase ::= CASE cexp:e COLON cstmts:ls BREAK SEMICOLON
            {:
                RESULT = new CCase(e, ls);
            :}
        | DEFAULT COLON cstmts:ls BREAK SEMICOLON
            {:
                RESULT = new CCase(ls);
            :}
        ;

/********************** ciclos ************************************/

cfor_stmt ::= FOR:f LPAREN cfor_reduced_stmt:s1 SEMICOLON 
            cexp:c SEMICOLON cfor_reduced_stmt:s2 RPAREN LBRACE cstmts:ls RBRACE
            {:
                RESULT = new CForAst(
                    new Position(fleft, fright),
                    ls, s1, s2, c
                );
            :}
        ;

cfor_reduced_stmt ::= c_jinvocation:li
            {:
                RESULT = new CObjectInv(li);
            :}
        | c_pinvocation:pi
            {:
                RESULT = pi.toStmt();
            :}
        | cassign:s
            {: RESULT = s; :}
        | /* empty */
            {: RESULT = null; :}
        ;


cwhile_stmt ::= WHILE:w LPAREN cexp:c RPAREN LBRACE cstmts:ls RBRACE
            {:
                RESULT = new CWhileAst(
                    new Position(wleft, wright),
                    ls, c
                );
            :}
        ;

cdo_while_stmt ::= DO:d LBRACE cstmts:ls RBRACE 
        WHILE LPAREN cexp:c RPAREN SEMICOLON
            {:
                RESULT = new CDoWhile(
                    new Position(dleft, dright),
                    ls, c
                );
            :}
        ;

/************************* invocations *****************************/

c_jinvocation ::= JAVA DOT ID:i jaccess:li
            {:
                RESULT = astGen.genListInv(
                    li, new JVarUse(new Position(ileft, iright), i, JContextRef.Local)
                );
            :}
        | JAVA DOT ID:i carray_dims:lce jaccess:li
            {:
                RESULT = astGen.genListInv(
                    li, new FromCArrUse(new Position(ileft, iright), i, lce)
                );
            :}
        ;

c_pinvocation ::= PASCAL DOT ID:i LPAREN RPAREN
            {:
                RESULT = new CMethodPass(
                    new Label(i, new Position(ileft, iright))
                );
            :}
        | PASCAL DOT ID:i LPAREN cparams:le RPAREN
            {:
                RESULT = new CMethodPass(
                    new Label(i, new Position(ileft, iright)),
                    le
                );
            :}
        ;

/*---------------------------- EXPRESSIONS ------------------------------*/

cexp ::= cexp:e1 AND:o cexp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.And, 
                    e1, e2
                );  
            :}
        | cexp:e1 OR:o cexp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Or, 
                    e1, e2
                ); 
            :}
        | NOT:o cexp:e
            {:
                RESULT = new CUnaryOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Not,
                    e
                );
            :}
        | cbool_exp:e
            {:
                RESULT = e;
            :}
        ;

cbool_exp ::= carit_exp:e1 EQUALS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.EqualsTo, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 DIFFERENT:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.DifferentTo, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 GRATER:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.GraterThan, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 LESS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.LessThan, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 GRATER_EQUALS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.GraterEq, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 LESS_EQUALS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.LessEq, 
                    e1, e2
                ); 
            :}
        | carit_exp:e
            {:
                RESULT = e;
            :}
        ;

carit_exp ::= carit_exp:e1 PLUS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Addition, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 MINUS:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Substraction, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 TIMES:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Multiplication, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 DIV:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Division, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 MOD:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Module, 
                    e1, e2
                ); 
            :}
        | carit_exp:e1 POWER:o carit_exp:e2
            {:
                RESULT = new COperation(
                    new Position(oleft, oright),
                    DefiniteOperation.Power, 
                    e1, e2
                ); 
            :}
        | cliterals:e
            {:
                RESULT = e;
            :}
        | c_jinvocation:li
            {:
                RESULT = new CObjectUseExp(li);
            :}
        | c_pinvocation:pi
            {:
                RESULT = pi.toExp();
            :}
        | ID:i
            {:
                RESULT = new CVarUse(
                    new Position(ileft, iright), i
                );
            :}
        | ID:i carray_dims:ac
            {:
                RESULT = new CVarArrayUse(
                    new Position(ileft, iright),
                    i, ac
                );
            :}
        %prec UMINUS
        | LPAREN cexp:e RPAREN
            {:
                RESULT = e;
            :}
        %prec UMINUS
        | PLUS:o carit_exp:e
            {:
                RESULT = new CUnaryOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Addition,
                    e
                );
            :}
        %prec UMINUS
        | MINUS:o carit_exp:e
            {:
                RESULT = new CUnaryOperation(
                    new Position(oleft, oright), 
                    DefiniteOperation.Substraction,
                    e
                );
            :}
        ;